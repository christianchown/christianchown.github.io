{"version":3,"sources":["data.ts","Header.tsx","getPosition.ts","Point.tsx","Connection.tsx","findRoutes.ts","AnimatingRoute.tsx","RunningRoutes.tsx","Routes.tsx","RoutingContext.ts","RouteDetail.tsx","RouteDetails.tsx","getRouteLength.ts","Instructions.tsx","getBestRoutes.ts","routeReducer.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["oneWayPoints","a","c","d","f","b","e","g","h","points","Object","keys","reduce","point","destPoints","forEach","dest","Header","className","getPosition","width","height","pointKey","total","index","findIndex","p","radians","Math","PI","radius","left","sin","top","cos","ButtonOrDiv","onClick","selected","clickable","style","children","Point","size","clickPoint","position","useCallback","precisionRound","number","precision","factor","pow","round","Connection","name","source","distance","sourcePos","destPos","center","diffLeft","diffTop","diameter","sqrt","asine","asin","angle","line","transform","findRoutes","startAt","condition","routes","route","waypoint","i","push","beenAt","slice","map","goingTowards","DURATION","AnimatingRoute","waypointRoute","useMemo","startPosition","length","endPosition","animationName","join","keyframes","keyframeStyle","document","createElement","type","appendChild","createTextNode","getElementsByTagName","key","animationTimingFunction","animationDuration","animationDelay","animationIterationCount","animationDirection","animationFillMode","unstartedWaypoint","started","uncompletedWaypoint","completed","RunningRoutes","endAt","dispatch","useEffect","unstartedRoute","setTimeout","targetPoint","inProgress","Routes","pointA","pointB","pointKeys","container","useRef","useState","setSize","resizeObserver","ResizeObserver","entries","node","target","clientWidth","clientHeight","current","observe","disconnect","ref","Fragment","undefined","filter","connection","toString","charCodeAt","defaultOptions","React","createContext","RouteDetail","start","RouteDetails","getRouteLength","destination","Instructions","busy","reset","cheeky","setCheeky","cheekyMessage","setCheekyMessage","cheekyButton","clickReset","RoutingContext","Consumer","bestRoutes","best","routeDistance","getBestRoutes","role","aria-label","routeReducer","action","routeToMatch","theseRoutes","some","r","completedRoute","movingForwards","newTargets","t","newTarget","incompleteWaypoint","Boolean","window","location","hostname","match","ReactDOM","render","setPointA","setPointB","useReducer","setBusy","clicked","startingRoutes","Provider","value","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.29f382f5.chunk.js","sourcesContent":["const oneWayPoints = {\n  a: {\n    c: 2\n  },\n  c: {\n    d: 1,\n    f: 4\n  },\n  b: {\n    d: 4,\n    e: 7\n  },\n  d: {\n    f: 1,\n    g: 2\n  },\n  f: {\n    g: 3\n  },\n  g: {\n    h: 4\n  },\n  e: {\n    h: 10\n  },\n  h: {}\n};\n\nexport const points = Object.keys(oneWayPoints).reduce(\n  (a, point) => {\n    const destPoints = oneWayPoints[point as keyof typeof oneWayPoints];\n    Object.keys(destPoints).forEach(dest => {\n      a[dest as keyof typeof a] = {\n        ...(a[dest as keyof typeof destPoints] || {}),\n        [point]:\n          oneWayPoints[point as keyof typeof oneWayPoints][\n            dest as keyof typeof destPoints\n          ]\n      };\n    });\n    return a;\n  },\n  oneWayPoints as {\n    [source: string]: {\n      [dest: string]: number;\n    };\n  }\n);\n\nexport type Point = keyof typeof points;\nexport type Distance = {\n  [dest in Point]?: number;\n};\nexport type Distances = {\n  [source in Point]: Distance;\n};\n","import React from \"react\";\nimport \"./Header.scss\";\n\nexport default function Header() {\n  return (\n    <header className=\"header\">\n      <h1 className=\"header__title\">Capita React Coding Exercise</h1>\n    </header>\n  );\n}\n","import { Point, points } from \"./data\";\n\nexport default function getPosition({\n  width,\n  height,\n  pointKey,\n  total\n}: {\n  width: number;\n  height: number;\n  pointKey: Point;\n  total: number;\n}) {\n  const index = Object.keys(points).findIndex(p => p === pointKey);\n  const radians = (2 * Math.PI * (index + total / 2)) / total;\n  const radius = (width > height ? height : width) / 2;\n  return {\n    left: width / 2 + 10 + Math.sin(radians) * radius,\n    top: height / 2 + Math.cos(radians) * radius\n  };\n}\n","import React, { CSSProperties, useCallback } from \"react\";\nimport { Point as PointKey } from \"./data\";\nimport getPosition from \"./getPosition\";\nimport \"./Point.scss\";\n\nfunction ButtonOrDiv({\n  onClick,\n  selected,\n  clickable,\n  style,\n  children\n}: {\n  onClick: () => void;\n  selected: boolean;\n  clickable: boolean;\n  style: CSSProperties;\n  children: React.ReactNode;\n}) {\n  if (selected) {\n    return (\n      <div className=\"point point--selected\" style={style}>\n        {children}\n      </div>\n    );\n  }\n  if (!clickable) {\n    return (\n      <div className=\"point point--inactive\" style={style}>\n        {children}\n      </div>\n    );\n  }\n  return (\n    <button className=\"point\" onClick={onClick} style={style}>\n      {children}\n    </button>\n  );\n}\n\nexport default function Point({\n  pointKey,\n  total,\n  size: [width, height],\n  clickPoint,\n  selected\n}: {\n  pointKey: PointKey;\n  total: number;\n  size: [number, number];\n  clickPoint?: (point: PointKey) => void;\n  selected: boolean;\n}) {\n  const style: CSSProperties = {\n    position: \"absolute\",\n    ...getPosition({ width, height, pointKey, total })\n  };\n  const onClick = useCallback(() => {\n    if (clickPoint) {\n      clickPoint(pointKey);\n    }\n  }, [clickPoint, pointKey]);\n  if (!width || !height) {\n    return null;\n  }\n  return (\n    <ButtonOrDiv\n      selected={selected}\n      clickable={!!clickPoint}\n      style={style}\n      onClick={onClick}\n    >\n      <div className=\"point__title\">{pointKey}</div>\n    </ButtonOrDiv>\n  );\n}\n","import React, { CSSProperties } from \"react\";\nimport getPosition from \"./getPosition\";\nimport \"./Connection.scss\";\nimport { Point } from \"./data\";\n\nfunction precisionRound(number: number, precision: number) {\n  const factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\n\nexport default function Connection({\n  name,\n  source,\n  dest,\n  distance,\n  total,\n  size: [width, height]\n}: {\n  name: string;\n  source: Point;\n  dest: Point;\n  distance: number;\n  total: number;\n  size: [number, number];\n}) {\n  if (!width || !height) {\n    return null;\n  }\n  const sourcePos = getPosition({ width, height, pointKey: source, total });\n  const destPos = getPosition({ width, height, pointKey: dest, total });\n  const centreLeft = (sourcePos.left + destPos.left) / 2;\n  const centreTop = (sourcePos.top + destPos.top) / 2;\n  const center: CSSProperties = {\n    position: \"absolute\",\n    left: centreLeft,\n    top: centreTop\n  };\n  const left = sourcePos.left;\n  const top = sourcePos.top;\n  const diffLeft = sourcePos.left - destPos.left;\n  const diffTop = sourcePos.top - destPos.top;\n  const diameter = Math.sqrt(diffLeft * diffLeft + diffTop * diffTop);\n\n  const asine =\n    precisionRound(sourcePos.left, 3) === precisionRound(destPos.left, 3)\n      ? 0\n      : Math.asin(diffLeft / diameter);\n  const angle =\n    sourcePos.top > destPos.top\n      ? (Math.PI * 3) / 2 - asine\n      : Math.PI / 2 + asine;\n  const line: CSSProperties = {\n    position: \"absolute\",\n    left,\n    top,\n    width: diameter,\n    transform: `translate(-${diameter /\n      2}px,0) rotate(${angle}rad) translate(${diameter / 2}px,0)`\n  };\n  return (\n    <div className=\"connection\">\n      <div className=\"connection__line\" style={line} />\n      <div className=\"connection__distance\" style={center}>\n        {name} {distance}\n      </div>\n    </div>\n  );\n}\n","import { RunningRoute, Waypoint } from \"./RoutingContext\";\nimport { Point } from \"./data\";\n\nexport interface WaypointRoute {\n  beenAt: Point[];\n  waypoint: Waypoint;\n}\n\nexport default function findRoutes(\n  startAt: Point,\n  condition: (waypoint: Waypoint) => boolean\n) {\n  return function findRoutesWhere(routes: RunningRoute[]) {\n    return routes.reduce(\n      (a, route) => {\n        return route.reduce((b, waypoint, i) => {\n          if (condition(waypoint)) {\n            b.push({\n              beenAt: [\n                startAt,\n                ...(i === 0\n                  ? []\n                  : route.slice(0, i).map(waypoint => waypoint.goingTowards))\n              ],\n              waypoint\n            });\n          }\n          return b;\n        }, a);\n      },\n      [] as WaypointRoute[]\n    );\n  };\n}\n","import React, { useMemo } from \"react\";\nimport getPosition from \"./getPosition\";\nimport { WaypointRoute } from \"./findRoutes\";\nimport \"./AnimatingRoute.scss\";\n\nexport const DURATION = 0.5;\n\nexport default function AnimatingRoute({\n  waypointRoute,\n  size: [width, height],\n  total\n}: {\n  waypointRoute: WaypointRoute;\n  size: [number, number];\n  total: number;\n}) {\n  const memoised = useMemo(() => {\n    const startPosition = getPosition({\n      width,\n      height,\n      pointKey: waypointRoute.beenAt[waypointRoute.beenAt.length - 1],\n      total\n    });\n    const endPosition = getPosition({\n      width,\n      height,\n      pointKey: waypointRoute.waypoint.goingTowards,\n      total\n    });\n    const diffLeft = endPosition.left - startPosition.left;\n    const diffTop = endPosition.top - startPosition.top;\n    const animationName = `animate-${waypointRoute.beenAt.join(\"\")}${\n      waypointRoute.waypoint.goingTowards\n    }-${Math.round(diffLeft)}-${Math.round(diffTop)}`;\n    const keyframes = `@keyframes ${animationName} {\n      0% {\n        transform: translate(0, 0);\n      }\n      100% {\n        transform: translate(${diffLeft}px, ${diffTop}px);\n      }\n    }`;\n    const keyframeStyle = document.createElement(\"style\");\n    keyframeStyle.type = \"text/css\";\n    keyframeStyle.appendChild(document.createTextNode(keyframes));\n    document.getElementsByTagName(\"head\")[0].appendChild(keyframeStyle);\n\n    return (\n      <div\n        className=\"animating-route\"\n        key={`from${waypointRoute.beenAt.join(\"\")}to${\n          waypointRoute.waypoint.goingTowards\n        }`}\n        style={{\n          position: \"absolute\",\n          animationName,\n          animationTimingFunction: \"linear\",\n          animationDuration: `${DURATION * waypointRoute.waypoint.distance}s`,\n          animationDelay: \"0.0s\",\n          animationIterationCount: 1,\n          animationDirection: \"normal\",\n          animationFillMode: \"forwards\",\n          ...startPosition\n        }}\n      />\n    );\n  }, [\n    width,\n    height,\n    waypointRoute.beenAt,\n    waypointRoute.waypoint.goingTowards,\n    waypointRoute.waypoint.distance,\n    total\n  ]);\n  return memoised;\n}\n","import React, { useEffect } from \"react\";\nimport { RouteAction } from \"./routeReducer\";\nimport { RunningRoute, Waypoint } from \"./RoutingContext\";\nimport { Point } from \"./data\";\nimport findRoutes from \"./findRoutes\";\nimport AnimatingRoute, { DURATION } from \"./AnimatingRoute\";\n\nconst unstartedWaypoint = (waypoint: Waypoint) => !waypoint.started;\nconst uncompletedWaypoint = (waypoint: Waypoint) =>\n  waypoint.started && !waypoint.completed;\n\nexport default function RunningRoutes({\n  startAt,\n  endAt,\n  routes,\n  dispatch,\n  size,\n  total\n}: {\n  startAt?: Point;\n  endAt?: Point;\n  routes: RunningRoute[];\n  dispatch: React.Dispatch<RouteAction>;\n  size: [number, number];\n  total: number;\n}) {\n  useEffect(() => {\n    if (startAt && endAt) {\n      findRoutes(startAt, unstartedWaypoint)(routes).forEach(unstartedRoute => {\n        dispatch({\n          type: \"START\",\n          unstartedRoute\n        });\n        setTimeout(() => {\n          dispatch({ type: \"END\", unstartedRoute, targetPoint: endAt });\n        }, DURATION * 1000 * unstartedRoute.waypoint.distance);\n      });\n    }\n  }, [dispatch, endAt, routes, startAt]);\n  if (!startAt) {\n    return null;\n  }\n  const inProgress = findRoutes(startAt, uncompletedWaypoint)(routes);\n  return (\n    <>\n      {inProgress.map(waypointRoute => (\n        <AnimatingRoute\n          waypointRoute={waypointRoute}\n          key={`animating${waypointRoute.beenAt.join(\"\")}${\n            waypointRoute.waypoint.goingTowards\n          }`}\n          size={size}\n          total={total}\n        />\n      ))}\n    </>\n  );\n}\n","import React, { useRef, useState, useEffect } from \"react\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport { Distances, Point as PointKey } from \"./data\";\nimport Point from \"./Point\";\nimport Connection from \"./Connection\";\nimport RunningRoutes from \"./RunningRoutes\";\nimport \"./Routes.scss\";\nimport { RunningRoute } from \"./RoutingContext\";\nimport { RouteAction } from \"./routeReducer\";\n\nexport default function Routes({\n  points,\n  pointA,\n  pointB,\n  clickPoint,\n  routes,\n  dispatch\n}: {\n  points: Distances;\n  pointA?: PointKey;\n  pointB?: PointKey;\n  clickPoint?: (point: PointKey) => void;\n  routes: RunningRoute[];\n  dispatch: React.Dispatch<RouteAction>;\n}) {\n  const pointKeys = Object.keys(points) as PointKey[];\n  const container = useRef<HTMLDivElement>(null);\n  const [size, setSize] = useState<[number, number]>([0, 0]);\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(entries => {\n      const node = entries[0].target;\n      setSize([node.clientWidth - 60, node.clientHeight]);\n    });\n    if (container.current) {\n      resizeObserver.observe(container.current);\n    }\n    return resizeObserver.disconnect;\n  }, []);\n  return (\n    <div className=\"routes\" ref={container}>\n      {pointKeys.map(pointKey => (\n        <React.Fragment key={pointKey}>\n          <Point\n            pointKey={pointKey}\n            total={pointKeys.length}\n            size={size}\n            clickPoint={\n              pointKey === pointA || pointKey === pointB\n                ? undefined\n                : clickPoint\n            }\n            selected={pointKey === pointA || pointKey === pointB}\n          />\n          {(Object.keys(points[pointKey]) as PointKey[])\n            .filter(\n              connection =>\n                connection.toString().charCodeAt(0) >\n                pointKey.toString().charCodeAt(0)\n            )\n            .map(connection => (\n              <Connection\n                key={`${pointKey}â†’${connection}`}\n                name={`${pointKey}â†’${connection}`}\n                source={pointKey}\n                dest={connection}\n                total={pointKeys.length}\n                size={size}\n                distance={points[pointKey][connection]!}\n              />\n            ))}\n        </React.Fragment>\n      ))}\n      <RunningRoutes\n        startAt={pointA}\n        endAt={pointB}\n        routes={routes}\n        dispatch={dispatch}\n        size={size}\n        total={pointKeys.length}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Point } from \"./data\";\n\nexport interface Waypoint {\n  goingTowards: Point;\n  distance: number;\n  started: boolean;\n  completed: boolean;\n}\n\nexport type RunningRoute = Waypoint[];\n\nexport const defaultOptions: {\n  pointA?: Point;\n  pointB?: Point;\n  routes: RunningRoute[];\n} = {\n  pointA: undefined,\n  pointB: undefined,\n  routes: []\n};\nexport default React.createContext(defaultOptions);\n","import React from \"react\";\nimport { RunningRoute } from \"./RoutingContext\";\nimport { Point } from \"./data\";\nimport \"./RouteDetail.scss\";\n\nexport default function RouteDetail({\n  start,\n  route,\n  name\n}: {\n  start: Point;\n  route: RunningRoute;\n  name: string;\n}) {\n  return (\n    <span className=\"route-detail\">\n      <span className=\"route-detail__point\">{start}</span>\n      {route.map(waypoint => (\n        <React.Fragment key={`${name}${waypoint.goingTowards}`}>\n          {\" \"}\n          â†’ <span className=\"route-detail__point\">\n            {waypoint.goingTowards}\n          </span>{\" \"}\n          <span className=\"route-detail__distance\">{waypoint.distance}</span>\n        </React.Fragment>\n      ))}\n    </span>\n  );\n}\n","import React from \"react\";\nimport { RunningRoute } from \"./RoutingContext\";\nimport RouteDetail from \"./RouteDetail\";\nimport { Point } from \"./data\";\n\nexport default function RouteDetails({\n  name,\n  start,\n  routes\n}: {\n  name: string;\n  start: Point;\n  routes: RunningRoute[];\n}) {\n  if (routes.length === 0) {\n    return null;\n  }\n  return (\n    <ul className=\"route-details\">\n      {routes.map((route, i) => (\n        <li key={`${name}${i}`} className=\"route-details__detail\">\n          <RouteDetail name={`${name}${i}`} start={start} route={route} />\n        </li>\n      ))}\n    </ul>\n  );\n}\n","import { Point } from \"./data\";\nimport { RunningRoute } from \"./RoutingContext\";\n\nexport default function getRouteLength(\n  destination: Point,\n  route: RunningRoute\n): number | undefined {\n  if (route.length === 0) {\n    return undefined;\n  }\n  if (route[route.length - 1].goingTowards !== destination) {\n    return undefined;\n  }\n  return route.reduce((total, waypoint) => {\n    return total + waypoint.distance;\n  }, 0);\n}\n","import React, { useState, useCallback } from \"react\";\nimport RoutingContext from \"./RoutingContext\";\nimport RouteDetail from \"./RouteDetail\";\nimport RouteDetails from \"./RouteDetails\";\nimport getBestRoutes from \"./getBestRoutes\";\nimport getRouteLength from \"./getRouteLength\";\nimport \"./Instructions.scss\";\n\nexport default function Instructions({\n  busy,\n  reset,\n  cheeky,\n  setCheeky\n}: {\n  busy: boolean;\n  reset: () => void;\n  cheeky: boolean;\n  setCheeky: (c: boolean) => void;\n}) {\n  const [cheekyMessage, setCheekyMessage] = useState(false);\n  const cheekyButton = useCallback(() => {\n    setCheeky(false);\n    setCheekyMessage(true);\n  }, [setCheeky]);\n  const clickReset = useCallback(() => {\n    setCheekyMessage(false);\n    reset();\n  }, [reset]);\n  return (\n    <RoutingContext.Consumer>\n      {({ pointA, pointB, routes }) => {\n        if (!pointA) {\n          return (\n            <div className=\"instructions\">\n              <p className=\"instructions__text\">Click on your first point.</p>\n            </div>\n          );\n        }\n        if (!pointB) {\n          return (\n            <div className=\"instructions\">\n              <p className=\"instructions__text\">\n                Measuring the shortest distance from point{\" \"}\n                <span className=\"instructions__selected-point\">{pointA}</span>.\n              </p>\n              <p className=\"instructions__text\">\n                Now click on your second point.\n              </p>\n            </div>\n          );\n        }\n        if (!busy) {\n          const bestRoutes = getBestRoutes(pointA, pointB, routes);\n          return (\n            <div className=\"instructions\">\n              <p className=\"instructions__text\">Done!</p>\n              {bestRoutes.length === 0 && (\n                <p className=\"instructions__text\">\n                  Oh dear. There are no routes between{\" \"}\n                  <span className=\"instructions__selected-point\">{pointA}</span>{\" \"}\n                  and{\" \"}\n                  <span className=\"instructions__selected-point\">{pointB}</span>\n                  .\n                </p>\n              )}{\" \"}\n              {bestRoutes.length === 1 && (\n                <p className=\"instructions__text\">\n                  The best route is:{\" \"}\n                  <RouteDetail\n                    name=\"best\"\n                    start={pointA}\n                    route={bestRoutes[0]}\n                  />\n                  with a distance of{\" \"}\n                  <span className=\"instructions__distance\">\n                    {getRouteLength(pointB, bestRoutes[0])}\n                  </span>\n                </p>\n              )}{\" \"}\n              {bestRoutes.length > 1 && (\n                <>\n                  <p className=\"instructions__text\">The best routes are:</p>\n                  <RouteDetails\n                    start={pointA}\n                    name=\"best\"\n                    routes={bestRoutes}\n                  />\n                </>\n              )}\n              {bestRoutes.length > 0 && cheeky && !cheekyMessage && (\n                <button\n                  className=\"instructions__button\"\n                  type=\"button\"\n                  onClick={cheekyButton}\n                >\n                  Would you like to view this solution using Dijkstra's\n                  algorithm?\n                </button>\n              )}\n              {cheekyMessage && (\n                <p className=\"instructions__cheeky\">\n                  You best hire me, then{\" \"}\n                  <span role=\"img\" aria-label=\"Wink wink\">\n                    ðŸ˜‰\n                  </span>\n                </p>\n              )}\n              <button\n                className=\"instructions__button\"\n                type=\"button\"\n                onClick={clickReset}\n              >\n                Click to reset\n              </button>\n              {!!routes.length && (\n                <p className=\"instructions__text\">Here's the routes I tried:</p>\n              )}\n              <RouteDetails start={pointA} name=\"all\" routes={routes} />\n            </div>\n          );\n        }\n        return (\n          <div className=\"instructions\">\n            <p className=\"instructions__text\">\n              Finding the shortest route from{\" \"}\n              <span className=\"instructions__selected-point\">{pointA}</span> to{\" \"}\n              <span className=\"instructions__selected-point\">{pointB}</span>...\n            </p>\n            <RouteDetails start={pointA} name=\"all\" routes={routes} />\n          </div>\n        );\n      }}\n    </RoutingContext.Consumer>\n  );\n}\n","import { Point } from \"./data\";\nimport { RunningRoute } from \"./RoutingContext\";\nimport getRouteLength from \"./getRouteLength\";\n\nexport default function getBestRoutes(\n  source: Point,\n  destination: Point,\n  routes: RunningRoute[]\n) {\n  if (routes.length === 0) {\n    return [];\n  }\n  const { best } = routes.reduce(\n    ({ distance, best }, route) => {\n      const routeDistance = getRouteLength(destination, route);\n      if (routeDistance === undefined) {\n        return { distance, best };\n      }\n      if (best.length === 0 || routeDistance < distance) {\n        return { distance: routeDistance, best: [route] };\n      }\n      if (routeDistance > distance) {\n        return { distance, best };\n      }\n      return { distance, best: [...best, route] };\n    },\n    { distance: 0, best: [] } as {\n      distance: number;\n      best: RunningRoute[];\n    }\n  );\n  return best;\n}\n","import { RunningRoute } from \"./RoutingContext\";\nimport { WaypointRoute } from \"./findRoutes\";\nimport { Point, points, Distance } from \"./data\";\n\ninterface ResetAction {\n  type: \"RESET\";\n}\ninterface InitAction {\n  type: \"INIT\";\n  routes: RunningRoute[];\n}\n\ninterface StartAction {\n  type: \"START\";\n  unstartedRoute: WaypointRoute;\n}\n\ninterface EndAction {\n  type: \"END\";\n  unstartedRoute: WaypointRoute;\n  targetPoint: Point;\n}\n\nexport type RouteAction = ResetAction | InitAction | StartAction | EndAction;\n\nexport default function routeReducer(\n  routes: RunningRoute[],\n  action: RouteAction\n) {\n  switch (action.type) {\n    case \"RESET\": {\n      return [];\n    }\n    case \"INIT\": {\n      return [...action.routes];\n    }\n    case \"START\": {\n      const routeToMatch = [\n        ...action.unstartedRoute.beenAt.slice(1),\n        action.unstartedRoute.waypoint.goingTowards\n      ];\n      return routes.map(route => {\n        const theseRoutes = route.map(waypoint => waypoint.goingTowards);\n        if (\n          theseRoutes.length !== routeToMatch.length ||\n          theseRoutes.some((r, i) => r !== routeToMatch[i])\n        ) {\n          return route;\n        }\n        return route.map(waypoint =>\n          waypoint.started ? waypoint : { ...waypoint, started: true }\n        );\n      });\n    }\n    case \"END\": {\n      const routeToMatch = [\n        ...action.unstartedRoute.beenAt.slice(1),\n        action.unstartedRoute.waypoint.goingTowards\n      ];\n      return routes.reduce(\n        (a, route) => {\n          const theseRoutes = route.map(waypoint => waypoint.goingTowards);\n          if (\n            theseRoutes.length !== routeToMatch.length ||\n            theseRoutes.some((r, i) => r !== routeToMatch[i])\n          ) {\n            return [...a, route];\n          }\n          const completedRoute = route.map(r =>\n            r.completed ? r : { ...r, completed: true }\n          );\n          const movingForwards: Distance =\n            points[action.unstartedRoute.waypoint.goingTowards];\n          const newTargets = Object.keys(movingForwards).filter(\n            target => !action.unstartedRoute.beenAt.some(t => target === t)\n          );\n          if (\n            action.unstartedRoute.waypoint.goingTowards ===\n              action.targetPoint ||\n            newTargets.length === 0\n          ) {\n            return [...a, completedRoute];\n          }\n          return [\n            ...a,\n            ...newTargets.map(newTarget => [\n              ...completedRoute,\n              {\n                goingTowards: newTarget as Point,\n                distance: movingForwards[newTarget as Point]!,\n                started: false,\n                completed: false\n              }\n            ])\n          ];\n        },\n        [] as RunningRoute[]\n      );\n    }\n    default:\n      return routes;\n  }\n}\n","import React, { useState, useCallback, useReducer, useEffect } from \"react\";\nimport \"./App.scss\";\nimport { points, Point as PointKey, Distance } from \"./data\";\nimport Header from \"./Header\";\nimport Routes from \"./Routes\";\nimport Instructions from \"./Instructions\";\nimport RoutingContext, { Waypoint } from \"./RoutingContext\";\nimport routeReducer from \"./routeReducer\";\nimport findRoutes from \"./findRoutes\";\n\nconst incompleteWaypoint = (route: Waypoint) => !route.completed;\n\nexport default function App() {\n  const [pointA, setPointA] = useState(undefined as undefined | PointKey);\n  const [pointB, setPointB] = useState(undefined as undefined | PointKey);\n  const [routes, dispatch] = useReducer(routeReducer, []);\n  const [busy, setBusy] = useState(false);\n  const [cheeky, setCheeky] = useState(true);\n\n  const clickPoint = useCallback(\n    async (clicked: PointKey) => {\n      if (!pointA) {\n        setPointA(clicked);\n      } else if (!pointB) {\n        setPointB(clicked);\n        setBusy(true);\n        const startingRoutes = Object.keys(points[pointA]) as PointKey[];\n        if (startingRoutes.length === 0) {\n          setBusy(false);\n        } else {\n          dispatch({\n            type: \"INIT\",\n            routes: startingRoutes.map(destination => [\n              {\n                goingTowards: destination,\n                distance: (points[pointA] as Distance)[destination]!,\n                completed: false,\n                started: false\n              }\n            ])\n          });\n        }\n      }\n    },\n    [pointA, pointB]\n  );\n  const reset = useCallback(() => {\n    setPointA(undefined);\n    setPointB(undefined);\n    dispatch({ type: \"RESET\" });\n    setBusy(false);\n  }, []);\n\n  useEffect(() => {\n    if (busy && routes.length && pointA) {\n      const incompleteRoutes = findRoutes(pointA, incompleteWaypoint)(routes);\n      if (incompleteRoutes.length === 0) {\n        setBusy(false);\n      }\n    }\n  }, [busy, pointA, routes]);\n  return (\n    <RoutingContext.Provider value={{ pointA, pointB, routes }}>\n      <article className=\"app\">\n        <section className=\"app__header\">\n          <Header />\n        </section>\n        <section className=\"app__body\">\n          <Routes\n            points={points}\n            pointA={pointA}\n            pointB={pointB}\n            clickPoint={busy || (pointA && pointB) ? undefined : clickPoint}\n            routes={routes}\n            dispatch={dispatch}\n          />\n        </section>\n        <section className=\"app__info\">\n          <Instructions\n            busy={busy}\n            reset={reset}\n            cheeky={cheeky}\n            setCheeky={setCheeky}\n          />\n        </section>\n      </article>\n    </RoutingContext.Provider>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}